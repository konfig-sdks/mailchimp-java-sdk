/*
 * Mailchimp Marketing API
 * Mailchimp is a marketing platform for small businesses. It offers an all-in-one marketing solution that includes email marketing, ads, landing pages, and automation. With Mailchimp, businesses can design and send targeted campaigns, analyze their performance, and grow their audience.
 *
 * The version of the OpenAPI document: 3.0.55
 * Contact: apihelp@mailchimp.com
 *
 * NOTE: This class is auto generated by Konfig (https://konfigthis.com).
 * Do not edit the class manually.
 */


package com.konfigthis.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.time.OffsetDateTime;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import org.apache.commons.lang3.StringUtils;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import com.konfigthis.client.JSON;

/**
 * Stats for the list. Many of these are cached for at least five minutes.
 */
@ApiModel(description = "Stats for the list. Many of these are cached for at least five minutes.")@javax.annotation.Generated(value = "Generated by https://konfigthis.com")
public class StatisticsProperty {
  public static final String SERIALIZED_NAME_MEMBER_COUNT = "member_count";
  @SerializedName(SERIALIZED_NAME_MEMBER_COUNT)
  private Integer memberCount;

  public static final String SERIALIZED_NAME_TOTAL_CONTACTS = "total_contacts";
  @SerializedName(SERIALIZED_NAME_TOTAL_CONTACTS)
  private Integer totalContacts;

  public static final String SERIALIZED_NAME_UNSUBSCRIBE_COUNT = "unsubscribe_count";
  @SerializedName(SERIALIZED_NAME_UNSUBSCRIBE_COUNT)
  private Integer unsubscribeCount;

  public static final String SERIALIZED_NAME_CLEANED_COUNT = "cleaned_count";
  @SerializedName(SERIALIZED_NAME_CLEANED_COUNT)
  private Integer cleanedCount;

  public static final String SERIALIZED_NAME_MEMBER_COUNT_SINCE_SEND = "member_count_since_send";
  @SerializedName(SERIALIZED_NAME_MEMBER_COUNT_SINCE_SEND)
  private Integer memberCountSinceSend;

  public static final String SERIALIZED_NAME_UNSUBSCRIBE_COUNT_SINCE_SEND = "unsubscribe_count_since_send";
  @SerializedName(SERIALIZED_NAME_UNSUBSCRIBE_COUNT_SINCE_SEND)
  private Integer unsubscribeCountSinceSend;

  public static final String SERIALIZED_NAME_CLEANED_COUNT_SINCE_SEND = "cleaned_count_since_send";
  @SerializedName(SERIALIZED_NAME_CLEANED_COUNT_SINCE_SEND)
  private Integer cleanedCountSinceSend;

  public static final String SERIALIZED_NAME_CAMPAIGN_COUNT = "campaign_count";
  @SerializedName(SERIALIZED_NAME_CAMPAIGN_COUNT)
  private Integer campaignCount;

  public static final String SERIALIZED_NAME_CAMPAIGN_LAST_SENT = "campaign_last_sent";
  @SerializedName(SERIALIZED_NAME_CAMPAIGN_LAST_SENT)
  private OffsetDateTime campaignLastSent;

  public static final String SERIALIZED_NAME_MERGE_FIELD_COUNT = "merge_field_count";
  @SerializedName(SERIALIZED_NAME_MERGE_FIELD_COUNT)
  private Integer mergeFieldCount;

  public static final String SERIALIZED_NAME_AVG_SUB_RATE = "avg_sub_rate";
  @SerializedName(SERIALIZED_NAME_AVG_SUB_RATE)
  private Double avgSubRate;

  public static final String SERIALIZED_NAME_AVG_UNSUB_RATE = "avg_unsub_rate";
  @SerializedName(SERIALIZED_NAME_AVG_UNSUB_RATE)
  private Double avgUnsubRate;

  public static final String SERIALIZED_NAME_TARGET_SUB_RATE = "target_sub_rate";
  @SerializedName(SERIALIZED_NAME_TARGET_SUB_RATE)
  private Double targetSubRate;

  public static final String SERIALIZED_NAME_OPEN_RATE = "open_rate";
  @SerializedName(SERIALIZED_NAME_OPEN_RATE)
  private Double openRate;

  public static final String SERIALIZED_NAME_CLICK_RATE = "click_rate";
  @SerializedName(SERIALIZED_NAME_CLICK_RATE)
  private Double clickRate;

  public static final String SERIALIZED_NAME_LAST_SUB_DATE = "last_sub_date";
  @SerializedName(SERIALIZED_NAME_LAST_SUB_DATE)
  private OffsetDateTime lastSubDate;

  public static final String SERIALIZED_NAME_LAST_UNSUB_DATE = "last_unsub_date";
  @SerializedName(SERIALIZED_NAME_LAST_UNSUB_DATE)
  private OffsetDateTime lastUnsubDate;

  public StatisticsProperty() {
  }

  
  public StatisticsProperty(
     Integer memberCount, 
     Integer totalContacts, 
     Integer unsubscribeCount, 
     Integer cleanedCount, 
     Integer memberCountSinceSend, 
     Integer unsubscribeCountSinceSend, 
     Integer cleanedCountSinceSend, 
     Integer campaignCount, 
     OffsetDateTime campaignLastSent, 
     Integer mergeFieldCount, 
     Double avgSubRate, 
     Double avgUnsubRate, 
     Double targetSubRate, 
     Double openRate, 
     Double clickRate, 
     OffsetDateTime lastSubDate, 
     OffsetDateTime lastUnsubDate
  ) {
    this();
    this.memberCount = memberCount;
    this.totalContacts = totalContacts;
    this.unsubscribeCount = unsubscribeCount;
    this.cleanedCount = cleanedCount;
    this.memberCountSinceSend = memberCountSinceSend;
    this.unsubscribeCountSinceSend = unsubscribeCountSinceSend;
    this.cleanedCountSinceSend = cleanedCountSinceSend;
    this.campaignCount = campaignCount;
    this.campaignLastSent = campaignLastSent;
    this.mergeFieldCount = mergeFieldCount;
    this.avgSubRate = avgSubRate;
    this.avgUnsubRate = avgUnsubRate;
    this.targetSubRate = targetSubRate;
    this.openRate = openRate;
    this.clickRate = clickRate;
    this.lastSubDate = lastSubDate;
    this.lastUnsubDate = lastUnsubDate;
  }

   /**
   * The number of active members in the list.
   * @return memberCount
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The number of active members in the list.")

  public Integer getMemberCount() {
    return memberCount;
  }




   /**
   * The number of contacts in the list, including subscribed, unsubscribed, pending, cleaned, deleted, transactional, and those that need to be reconfirmed. Requires include_total_contacts query parameter to be included.
   * @return totalContacts
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The number of contacts in the list, including subscribed, unsubscribed, pending, cleaned, deleted, transactional, and those that need to be reconfirmed. Requires include_total_contacts query parameter to be included.")

  public Integer getTotalContacts() {
    return totalContacts;
  }




   /**
   * The number of members who have unsubscribed from the list.
   * @return unsubscribeCount
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The number of members who have unsubscribed from the list.")

  public Integer getUnsubscribeCount() {
    return unsubscribeCount;
  }




   /**
   * The number of members cleaned from the list.
   * @return cleanedCount
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The number of members cleaned from the list.")

  public Integer getCleanedCount() {
    return cleanedCount;
  }




   /**
   * The number of active members in the list since the last campaign was sent.
   * @return memberCountSinceSend
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The number of active members in the list since the last campaign was sent.")

  public Integer getMemberCountSinceSend() {
    return memberCountSinceSend;
  }




   /**
   * The number of members who have unsubscribed since the last campaign was sent.
   * @return unsubscribeCountSinceSend
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The number of members who have unsubscribed since the last campaign was sent.")

  public Integer getUnsubscribeCountSinceSend() {
    return unsubscribeCountSinceSend;
  }




   /**
   * The number of members cleaned from the list since the last campaign was sent.
   * @return cleanedCountSinceSend
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The number of members cleaned from the list since the last campaign was sent.")

  public Integer getCleanedCountSinceSend() {
    return cleanedCountSinceSend;
  }




   /**
   * The number of campaigns in any status that use this list.
   * @return campaignCount
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The number of campaigns in any status that use this list.")

  public Integer getCampaignCount() {
    return campaignCount;
  }




   /**
   * The date and time the last campaign was sent to this list in ISO 8601 format. This is updated when a campaign is sent to 10 or more recipients.
   * @return campaignLastSent
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The date and time the last campaign was sent to this list in ISO 8601 format. This is updated when a campaign is sent to 10 or more recipients.")

  public OffsetDateTime getCampaignLastSent() {
    return campaignLastSent;
  }




   /**
   * The number of merge fields ([audience field](https://mailchimp.com/help/getting-started-with-merge-tags/)) for this list (doesn&#39;t include EMAIL).
   * @return mergeFieldCount
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The number of merge fields ([audience field](https://mailchimp.com/help/getting-started-with-merge-tags/)) for this list (doesn't include EMAIL).")

  public Integer getMergeFieldCount() {
    return mergeFieldCount;
  }




   /**
   * The average number of subscriptions per month for the list (not returned if we haven&#39;t calculated it yet).
   * @return avgSubRate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The average number of subscriptions per month for the list (not returned if we haven't calculated it yet).")

  public Double getAvgSubRate() {
    return avgSubRate;
  }




   /**
   * The average number of unsubscriptions per month for the list (not returned if we haven&#39;t calculated it yet).
   * @return avgUnsubRate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The average number of unsubscriptions per month for the list (not returned if we haven't calculated it yet).")

  public Double getAvgUnsubRate() {
    return avgUnsubRate;
  }




   /**
   * The target number of subscriptions per month for the list to keep it growing (not returned if we haven&#39;t calculated it yet).
   * @return targetSubRate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The target number of subscriptions per month for the list to keep it growing (not returned if we haven't calculated it yet).")

  public Double getTargetSubRate() {
    return targetSubRate;
  }




   /**
   * The average open rate (a percentage represented as a number between 0 and 100) per campaign for the list (not returned if we haven&#39;t calculated it yet).
   * @return openRate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The average open rate (a percentage represented as a number between 0 and 100) per campaign for the list (not returned if we haven't calculated it yet).")

  public Double getOpenRate() {
    return openRate;
  }




   /**
   * The average click rate (a percentage represented as a number between 0 and 100) per campaign for the list (not returned if we haven&#39;t calculated it yet).
   * @return clickRate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The average click rate (a percentage represented as a number between 0 and 100) per campaign for the list (not returned if we haven't calculated it yet).")

  public Double getClickRate() {
    return clickRate;
  }




   /**
   * The date and time of the last time someone subscribed to this list in ISO 8601 format.
   * @return lastSubDate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The date and time of the last time someone subscribed to this list in ISO 8601 format.")

  public OffsetDateTime getLastSubDate() {
    return lastSubDate;
  }




   /**
   * The date and time of the last time someone unsubscribed from this list in ISO 8601 format.
   * @return lastUnsubDate
  **/
  @javax.annotation.Nullable
  @ApiModelProperty(value = "The date and time of the last time someone unsubscribed from this list in ISO 8601 format.")

  public OffsetDateTime getLastUnsubDate() {
    return lastUnsubDate;
  }



  /**
   * A container for additional, undeclared properties.
   * This is a holder for any undeclared properties as specified with
   * the 'additionalProperties' keyword in the OAS document.
   */
  private Map<String, Object> additionalProperties;

  /**
   * Set the additional (undeclared) property with the specified name and value.
   * If the property does not already exist, create it otherwise replace it.
   *
   * @param key name of the property
   * @param value value of the property
   * @return the StatisticsProperty instance itself
   */
  public StatisticsProperty putAdditionalProperty(String key, Object value) {
    if (this.additionalProperties == null) {
        this.additionalProperties = new HashMap<String, Object>();
    }
    this.additionalProperties.put(key, value);
    return this;
  }

  /**
   * Return the additional (undeclared) property.
   *
   * @return a map of objects
   */
  public Map<String, Object> getAdditionalProperties() {
    return additionalProperties;
  }

  /**
   * Return the additional (undeclared) property with the specified name.
   *
   * @param key name of the property
   * @return an object
   */
  public Object getAdditionalProperty(String key) {
    if (this.additionalProperties == null) {
        return null;
    }
    return this.additionalProperties.get(key);
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    StatisticsProperty statisticsProperty = (StatisticsProperty) o;
    return Objects.equals(this.memberCount, statisticsProperty.memberCount) &&
        Objects.equals(this.totalContacts, statisticsProperty.totalContacts) &&
        Objects.equals(this.unsubscribeCount, statisticsProperty.unsubscribeCount) &&
        Objects.equals(this.cleanedCount, statisticsProperty.cleanedCount) &&
        Objects.equals(this.memberCountSinceSend, statisticsProperty.memberCountSinceSend) &&
        Objects.equals(this.unsubscribeCountSinceSend, statisticsProperty.unsubscribeCountSinceSend) &&
        Objects.equals(this.cleanedCountSinceSend, statisticsProperty.cleanedCountSinceSend) &&
        Objects.equals(this.campaignCount, statisticsProperty.campaignCount) &&
        Objects.equals(this.campaignLastSent, statisticsProperty.campaignLastSent) &&
        Objects.equals(this.mergeFieldCount, statisticsProperty.mergeFieldCount) &&
        Objects.equals(this.avgSubRate, statisticsProperty.avgSubRate) &&
        Objects.equals(this.avgUnsubRate, statisticsProperty.avgUnsubRate) &&
        Objects.equals(this.targetSubRate, statisticsProperty.targetSubRate) &&
        Objects.equals(this.openRate, statisticsProperty.openRate) &&
        Objects.equals(this.clickRate, statisticsProperty.clickRate) &&
        Objects.equals(this.lastSubDate, statisticsProperty.lastSubDate) &&
        Objects.equals(this.lastUnsubDate, statisticsProperty.lastUnsubDate)&&
        Objects.equals(this.additionalProperties, statisticsProperty.additionalProperties);
  }

  @Override
  public int hashCode() {
    return Objects.hash(memberCount, totalContacts, unsubscribeCount, cleanedCount, memberCountSinceSend, unsubscribeCountSinceSend, cleanedCountSinceSend, campaignCount, campaignLastSent, mergeFieldCount, avgSubRate, avgUnsubRate, targetSubRate, openRate, clickRate, lastSubDate, lastUnsubDate, additionalProperties);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class StatisticsProperty {\n");
    sb.append("    memberCount: ").append(toIndentedString(memberCount)).append("\n");
    sb.append("    totalContacts: ").append(toIndentedString(totalContacts)).append("\n");
    sb.append("    unsubscribeCount: ").append(toIndentedString(unsubscribeCount)).append("\n");
    sb.append("    cleanedCount: ").append(toIndentedString(cleanedCount)).append("\n");
    sb.append("    memberCountSinceSend: ").append(toIndentedString(memberCountSinceSend)).append("\n");
    sb.append("    unsubscribeCountSinceSend: ").append(toIndentedString(unsubscribeCountSinceSend)).append("\n");
    sb.append("    cleanedCountSinceSend: ").append(toIndentedString(cleanedCountSinceSend)).append("\n");
    sb.append("    campaignCount: ").append(toIndentedString(campaignCount)).append("\n");
    sb.append("    campaignLastSent: ").append(toIndentedString(campaignLastSent)).append("\n");
    sb.append("    mergeFieldCount: ").append(toIndentedString(mergeFieldCount)).append("\n");
    sb.append("    avgSubRate: ").append(toIndentedString(avgSubRate)).append("\n");
    sb.append("    avgUnsubRate: ").append(toIndentedString(avgUnsubRate)).append("\n");
    sb.append("    targetSubRate: ").append(toIndentedString(targetSubRate)).append("\n");
    sb.append("    openRate: ").append(toIndentedString(openRate)).append("\n");
    sb.append("    clickRate: ").append(toIndentedString(clickRate)).append("\n");
    sb.append("    lastSubDate: ").append(toIndentedString(lastSubDate)).append("\n");
    sb.append("    lastUnsubDate: ").append(toIndentedString(lastUnsubDate)).append("\n");
    sb.append("    additionalProperties: ").append(toIndentedString(additionalProperties)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("member_count");
    openapiFields.add("total_contacts");
    openapiFields.add("unsubscribe_count");
    openapiFields.add("cleaned_count");
    openapiFields.add("member_count_since_send");
    openapiFields.add("unsubscribe_count_since_send");
    openapiFields.add("cleaned_count_since_send");
    openapiFields.add("campaign_count");
    openapiFields.add("campaign_last_sent");
    openapiFields.add("merge_field_count");
    openapiFields.add("avg_sub_rate");
    openapiFields.add("avg_unsub_rate");
    openapiFields.add("target_sub_rate");
    openapiFields.add("open_rate");
    openapiFields.add("click_rate");
    openapiFields.add("last_sub_date");
    openapiFields.add("last_unsub_date");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to StatisticsProperty
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!StatisticsProperty.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in StatisticsProperty is not found in the empty JSON string", StatisticsProperty.openapiRequiredFields.toString()));
        }
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!StatisticsProperty.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'StatisticsProperty' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<StatisticsProperty> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(StatisticsProperty.class));

       return (TypeAdapter<T>) new TypeAdapter<StatisticsProperty>() {
           @Override
           public void write(JsonWriter out, StatisticsProperty value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             obj.remove("additionalProperties");
             // serialize additonal properties
             if (value.getAdditionalProperties() != null) {
               for (Map.Entry<String, Object> entry : value.getAdditionalProperties().entrySet()) {
                 if (entry.getValue() instanceof String)
                   obj.addProperty(entry.getKey(), (String) entry.getValue());
                 else if (entry.getValue() instanceof Number)
                   obj.addProperty(entry.getKey(), (Number) entry.getValue());
                 else if (entry.getValue() instanceof Boolean)
                   obj.addProperty(entry.getKey(), (Boolean) entry.getValue());
                 else if (entry.getValue() instanceof Character)
                   obj.addProperty(entry.getKey(), (Character) entry.getValue());
                 else {
                   obj.add(entry.getKey(), gson.toJsonTree(entry.getValue()).getAsJsonObject());
                 }
               }
             }
             elementAdapter.write(out, obj);
           }

           @Override
           public StatisticsProperty read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             // store additional fields in the deserialized instance
             StatisticsProperty instance = thisAdapter.fromJsonTree(jsonObj);
             for (Map.Entry<String, JsonElement> entry : jsonObj.entrySet()) {
               if (!openapiFields.contains(entry.getKey())) {
                 if (entry.getValue().isJsonPrimitive()) { // primitive type
                   if (entry.getValue().getAsJsonPrimitive().isString())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsString());
                   else if (entry.getValue().getAsJsonPrimitive().isNumber())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsNumber());
                   else if (entry.getValue().getAsJsonPrimitive().isBoolean())
                     instance.putAdditionalProperty(entry.getKey(), entry.getValue().getAsBoolean());
                   else
                     throw new IllegalArgumentException(String.format("The field `%s` has unknown primitive type. Value: %s", entry.getKey(), entry.getValue().toString()));
                 } else if (entry.getValue().isJsonArray()) {
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), List.class));
                 } else { // JSON object
                     instance.putAdditionalProperty(entry.getKey(), gson.fromJson(entry.getValue(), HashMap.class));
                 }
               }
             }
             return instance;
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of StatisticsProperty given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of StatisticsProperty
  * @throws IOException if the JSON string is invalid with respect to StatisticsProperty
  */
  public static StatisticsProperty fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, StatisticsProperty.class);
  }

 /**
  * Convert an instance of StatisticsProperty to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

